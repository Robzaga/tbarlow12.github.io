---
layout: post
title: Contribution Paper - Agile vs. Waterfall
---

##Introduction
“Science is what we understand well enough to explain to a computer. Art is everything else we do.” (Knuth, 1996) While computer science is often perceived as the study of the capabilities of a computer, it can more accurately be defined as the study of teaching a computer to perform meaningful tasks. In order to better understand the computer and optimize its performance, it is essential to understand the human computer from whence its algorithms, processes and ideas come. The improvement of the process of software development requires an understanding of how human beings, especially those working in teams, work most efficiently.

In “Changing the Paradigm of Software Engineering,” Rajlich describes that since the separation of software and hardware into separate fields in the 1950s (Rajlich, 2006), the process of software development has been constantly changing and evolving. As new technologies arise, this rapidly changing field of study has had to change the way problems are approached, thought about and solved. As Nerur and Balijepally describe in a reflection on Agile development, this has led to the development of many schools of thought, methodologies and practices which, in many cases, have stretched beyond the discipline of software development to affect the manner of human thinking and problem solving in general. (Nerur & Balijepally, 2007)

Currently, there exists a debate over which of two major methodologies, Agile and Waterfall, is better for the development of software and the progression of the field in general. Therefore, the purpose of this essay is to describe the advantages and disadvantages of each approach and suggest how to proceed when deciding which to use.

##Waterfall
The Waterfall method can be likened to the construction of a skyscraper. A great amount of effort is needed up-front to acquire necessary permits, assess the ground on which the building is being built, arrange outlines, blueprints and plans as well as address any major issues before a drop of concrete is placed or a single nail has been driven in. Once construction has begun, the client for whom the building is being built does not have the freedom to simply move the building without a massive expense of time and money. As inconvenient as it might be, this technique is necessary when dealing with such projects.

Just like the building of the skyscraper, the Waterfall method of software development does a large portion of the work required before a single line of code is written. It constitutes many hours of deciphering the directions of the client to create exactly what was asked, drawing diagrams to visualize the functionality of the program, designing databases to ensure optimum performance and determining the date at which the software will be ready for release. Prakash, Senthil Anand and Bhavani make sense of the Waterfall metaphor by describing the process as “…flowing steadily downwards through the phases of requirement analysis, design, implementation, testing, integration, and maintenance without going back and revisiting the requirements.” (Prakash, Senthil Anand, & Bhavani, 2012) While this can lend itself well to a large project, any fundamental changes to the project will cost a great deal of time and effort.

Sometimes, this style of work is needed. Especially in software like that of an airplane, where life or death depends on its flawless functionality, there must be an extensive planning process that ensures its performance. Short, quick releases that may or may not have “bugs” or “glitches” are not really an option. However, in an increasingly Internet-driven world with trends that change by the hour, many software-related problems can be solved more efficiently. There are times when a client may not know exactly what is needed. Their needs may change and companies need to adapt. For example, Serrador and Pinto use an example to explain the idea that failing to adapt software to business needs can prove damaging to a company. They explained that “…Motorola's multibillion-dollar Iridium project … could be considered a success on the basis it was ‘on time’ and ‘on budget’ from an engineering point of view, but was a catastrophic commercial failure because it did not adjust to what was being learned about the changing business environment.” (Serrador & Pinto, 2015) In order to make changes, those companies need to see those changes in the software that they use. Often, even if they do have a very specific vision for what they want, clients are not able to communicate that vision to a team of programmers accurately enough that the team can create that vision.
As mentioned, the requirements of modern software projects are constantly subject to change. Those changes can come from the client, but they can also come from developers that are learning throughout the process. Rajlich pointed out that “…30% of the requirements for Microsoft projects were not elicited in advance, but emerged only when the development was already under way, possibly as a result of the developer’s learning.” (Rajlich, 2006) The word development itself is defined as, “a state of growth or advancement.” It is important to note that growth and advancement are processes. They are not single events. Requirements for software change, grow and advance with the increase of the developer’s knowledge. The inflexibility of Waterfall can be inhibitive and even destructive.

Due to the fact that integration, testing and other important steps are put off until the end of the development cycle, many defects or errors are undetectable until the release date is too close. This is why, according to Ganesh and Thangasamy, schedules and estimates are not reliable when using the Waterfall methodology. (Ganesh & Thangasamy, 2012) However, because software development is a business, there are situations in which failing to meet a deadline is simply not an option. Some teams will release the faulty software anyway, leading to the dissatisfaction of a client who has already waited a considerable amount of time for the completed software.
Because of its inflexibility, inadaptability, and unpredictability, the Waterfall methodology, on its own, is clearly not enough. There may not be cause enough to eliminate it entirely because of its strength when creating large projects or those with a low margin of error, but it has simply fallen behind in the attempt to keep up with the current environment.

##Agile
In 2001, a group of programmers met at the Snowbird ski resort in Salt Lake City, Utah, to create what is known as the “Agile Manifesto,” a document that described a new system of software development that would replace more traditional methods throughout the field. In the document, its authors, Highsmith and Cockburn, defined Agile as, “the ability to create and respond to change.” (Vidgen & Wang, 2009) This shift in paradigm came at a time when the world was changing rapidly and the old way of doing things was simply not keeping up. This new method promised, “high customer satisfaction through three principles: quick delivery of quality software; active participation of concerned stakeholders; and creating and leveraging change.” (Nerur & Balijepally, 2007) In other words, Agile was to be focused on the principles or rapid release, increased frequency of feedback between developers and client, and heightened adaptability to the requirements of the project.
One of Agile’s greatest strengths is that of time management. Prakash, Senthil and Bhavani explain, “The Agile method promotes an iterative mechanism for producing software. It increases the iterative nature of the software lifecycle by tightening design-code-test loop to at least once a day as opposed to once per iteration… It leads to better quality software in a shorter period of time.” (Prakash, Senthil Anand, & Bhavani, 2012) By breaking down larger tasks into smaller ones and then “time-boxing” those tasks, development teams are able to make more accurate estimations on the amount of time require for a project. (Ganesh & Thangasamy, 2012) By creating an iterative atmosphere in which developers are expected to explain their progress on a daily basis, there is a greater sense of accountability and expectation. Teams are able to lessen the amount of wasted time in deciding what to do next and how to approach it.

Another advantage of using Agile is its focus on people and communication. Nerur and Balijepally summarize this attribute with the statement, “Agile methods are people-centric, recognizing the value competent people and their relationships bring to software development.” (Nerur & Balijepally, 2007) Agile has an increased focus on communication, not only between developers and team leaders, but with the clients as well. With increased transparency in the development process, meaning clients are able to know exactly what is going on with the project, clients are able to request any necessary changes to the program before the team has traveled too far down the wrong path. Mike Milinkovich, executive director of the Eclipse foundation since 2004, expressed that using transparent, Agile development has had massive advantages for his foundation while building Eclipse. (Prakash, Senthil Anand, & Bhavani, 2012) In Agile, collaboration is the cornerstone for creation.
According to the definition given in the Agile manifesto, the ability to adapt must be one of the pillars of the Agile workflow. One of the key aspects of Agile that makes it more adaptable than Waterfall and other traditional methods is that of “test-driven development,” meaning that tests of how the software should be working are written first rather than at the end of the process. This provides developers with a quick, automated way to verify program correctness at any time during development. Therefore, in order to make a change to the project specifications, a developer can simply add or modify the test cases to reflect the new desired behavior, and then write the code that satisfies those conditions.

Another reason for Agile’s high adaptability comes from a core principle of computer science called “abstraction.” Abstraction is a method of managing complexity, in which a developer can ignore details of any piece of code to focus on its overall functionality. Problems are broken down into smaller problems, those smaller problems are solved and then are used, building on each other, to solve the original problem. Using this technique can isolate the behavior and functionality of a piece of software, which facilitates change by allowing the developer to tweak a small part of the program in order to make a significant change. This philosophy can also apply to a team’s workflow. Along with abstraction, a key aspect of Agile is that of ownership, meaning that all developers are “owners” of certain pieces of the software. By letting developers take ownership of all pieces of software, team leaders can let the individual developers worry about the details of those pieces. When a change needs to be made, because the problem has been broken down into smaller problems, the team leader knows which team members need to make changes in their pieces for the change in the overall functionality to occur. As always, without daily communication between team members, this process becomes impossible.

However, even with all of the advantages of using Agile, there still exist some challenges. For example, many of the companies that began to transition to Agile, “have found out that the Agile practices are less burdensome and more in tune on small, standalone projects. There are complexities of scaling up and integrating them into traditional, top-down systems development organizations.” (Prakash, Senthil Anand, & Bhavani, 2012) Because Agile is based on small teams with daily meetings and constant feedback, it can be difficult to coordinate massive software projects with all teams on a daily basis. In an ideal world, every team and individual would understand every nuance and requirement of the project, but that is not often the reality.

Another challenge in the Agile workflow occurs when “potentially ambiguous requirement statements can be produced as the customer and product developer failed to collaborate sufficiently in the early stages of development. This risk increases in the Agile method because requirements are often written as story cards, which depends highly on face to face communication to resolve different requirement interpretations.” (Prakash, Senthil Anand, & Bhavani, 2012) With so many pieces of software being developed internationally, face to face communication is sometimes impossible. Agile’s emphasis on communication can, in some cases, become more of a hindrance than help.

##Transition
Many software teams and companies have long-ago decided to make the switch to Agile. However, one of the greatest challenges to these teams is the transition from the more traditional methods. When describing the reluctance of many in the field to adapt to the shift in paradigm, Rajlich said, “This resistance is fueled by the fact that as a result of the paradigm change, knowledge accumulated up to that point may lose its significance.” (Rajlich, 2006) Software developers experience change constantly. There is always a new tool or technology that they must learn in order to stay relevant in today’s field. However, to software developers, a change in development process is more than just a change in policy. It is an entirely new way of thinking. Some resist this change because of lack of understanding, some because of stubbornness, and others because of fear, along with many other motives. This lack of unity can be problematic because, “the Agile method requires a team to have a common focus, mutual trust and respect, and a collaborative, but speedy decision making process.” (Prakash, Senthil Anand, & Bhavani, 2012) If even part of the team is not on board for the change, Agile is not nearly as effective as it should be. Managers should be patient and understanding in transitioning their teams to a new school of thought, but they also need to be persistent in helping the team change its manner of thinking to the new methodology.

While difficult, this transition has occurred for many teams throughout the world. A case study of a team in India shows that many developers are more willing to make the change if it is made gradually. By incorporating pieces of the Agile puzzle step by step, the team was able to understand the full benefit of each piece and adapt to the new workflow. This transition resulted in a customer that was satisfied with the output that he was showcased and had very few suggestions from his end.” (Ganesh & Thangasamy, 2012)

##Conclusion
In his “Dual Hypotheses of Knowledge Discovery,” author Phillip Armour explained that, “We can only discover knowledge in an environment that contains that knowledge.” Similar to the case study of the team in India, it is hard for someone to appreciate a new way of doing things without doing them and seeing the benefit. In order for a developer to appreciate Agile, they must be immersed in an Agile environment.
As in most engineering issues, software development does not have a “one-size-fits-all” solution for every problem. There are tradeoffs, advantages and disadvantages for every solution. While evidence clearly shows that Waterfall, as a whole, has become outdated and ineffective, there could be pieces of its methodology that are effective for a given team. It would be unwise for team leaders and developers to ignore all aspects of Waterfall and blindly follow everything related to Agile, regardless of its effectiveness on their team. If a team is currently using Waterfall or another traditional workflow process, it would be prudent to slowly and gradually introduce pieces of Agile, determining by experience whether or not these pieces are effective within the team’s environment. Any team that is already using Agile should always be self-evaluating and deciding whether each piece of Agile is actually benefitting the team. Some might argue that, in order to reap all of Agile’s benefits, one must adhere to its principles religiously and without question. While consistency does have its benefits, one of the core principles of Agile is the ability to adapt and change according to circumstances. Nerur and Balijepally define this quality as “functionally rational,” explaining the goal of the Agile process is “facilitating learning and adaptation through the constant questioning of assumptions.” (Nerur & Balijepally, 2007) By constantly evaluating the effectiveness of a team’s current workflow, they are able to eliminate hindrances and impracticalities and take full advantage of all practical benefits of either system.


References
Armour, P. G. (2005, January). The Unconscious Art of Software Testing. Communications of the ACM, 48, 15-18.
Ganesh, N., & Thangasamy, S. (2012, January 01). Lessons Learned in Transforming from Traditional to Agile Development. Journal of Computer Science, 8(3), 389-392.
Knuth, D. (1996). Foreword to the book "A=B". In M. Petkovsek, H. Wilf, & D. Zeilberger, A=B.
Nerur, S., & Balijepally, V. (2007, March). Theoretical Reflections on AGILE DEVELOPMENT METHODOLOGIES. Communications of the ACM, 50, 79-83.
Prakash, V., Senthil Anand, N., & Bhavani, R. (2012, May). Agile-Fall Process Flow Model - A Right Candidate for Implementation in Software Development and Testing Processes for Software Organizations. International Journal of Computer Science, 9(3), 457-461.
Rajlich, V. (2006, August). Changing the paradigm of software engineering. Communications of the ACM, 49(8), 67-70.
Serrador, P., & Pinto, J. K. (2015, July). Does Agile work? — A quantitative analysis of agile project success. International Journal of Project Management, 33(5), 1040-1051.
Vidgen, R., & Wang, X. (2009). Coevolving Systems and the Organization of Agile Software Development. Information Systems Research, 355-376.
